.\" sc - Scientific Calculator man page
.TH SC 1 "December 2024" "sc 1.0.0" "User Commands"
.SH NAME
sc \- arbitrary precision scientific calculator
.SH SYNOPSIS
.B sc
.RI [ expression ]
.br
.B sc
.RI [ options ]
.SH DESCRIPTION
.B sc
is a high-precision scientific calculator with support for complex numbers,
matrices, statistics, financial calculations, and IEEE 754-2008 compliant
arithmetic. It provides 128-bit internal precision (approximately 38
significant decimal digits).
.PP
When invoked without arguments,
.B sc
enters interactive mode with a REPL (Read-Eval-Print Loop).
When given an expression as an argument, it evaluates and prints the result.
.SH OPTIONS
.TP
.B \-h, \-\-help
Display help message and exit.
.TP
.B \-v, \-\-version
Display version information and exit.
.SH BASIC ARITHMETIC
.SS Operators
.TP
.B +
Addition
.TP
.B \-
Subtraction
.TP
.B * \fRor\fB ×
Multiplication (Unicode × supported)
.TP
.B / \fRor\fB ÷
Division (Unicode ÷ supported)
.TP
.B %
Modulo (floor division remainder)
.TP
.B ^
Exponentiation (right-associative: 2^3^2 = 2^9 = 512)
.TP
.B !
Factorial (postfix: 5! = 120)
.TP
.B \\\\
Left division (a\\\\b = b/a, useful for matrices)
.SS Comparison Operators
Return \fBtrue\fR or \fBfalse\fR:
.TP
.B = \fRor\fB ==
Equal
.TP
.B <>
Not equal
.TP
.B <
Less than
.TP
.B <=
Less than or equal
.TP
.B >
Greater than
.TP
.B >=
Greater than or equal
.TP
.B ~=
Approximately equal (within 5% of left operand's absolute value)
.SS Boolean Operators
Combine comparisons logically. Return \fBtrue\fR or \fBfalse\fR:
.TP
.B and \fRor\fB &&
Logical AND
.TP
.B or \fRor\fB ||
Logical OR
.TP
.B xor
Logical exclusive OR
.TP
.B not \fRor\fB ~
Logical NOT (prefix operator)
.PP
Examples:
.nf
    1<2 and 3<4          # true
    1>2 or 3<4           # true
    not 1>2              # true
    (1<2 or 5>10) and 3<4   # true
.fi
.SS Exit Codes
When used in shell scripts, \fBsc\fR returns:
.TP
.B 0
Result is true or non-zero
.TP
.B 1
Result is false or zero
.PP
This enables use in shell conditionals:
.nf
    if sc "isprime(17)"; then echo "prime"; fi
    if sc "x~=expected"; then echo "close enough"; fi
.fi
.SS Order of Operations (BEDMAS)
Brackets, Exponents, Division/Multiplication (left-to-right),
Addition/Subtraction (left-to-right).
.PP
Example: 2 + 3 * 4 = 14 (not 20)
.SS Special Values
.TP
.B pi
π = 3.14159265358979323846...
.TP
.B e
Euler's number = 2.71828182845904523536...
.TP
.B i
Imaginary unit (√-1)
.TP
.B ans
Result of the last calculation
.TP
.B inf
Positive infinity
.TP
.B nan
Not a Number
.SH VARIABLES
Variables are assigned with \fB=\fR:
.PP
.RS
>>> x = 5
.br
>>> y = x^2 + 3*x + 1
.br
>>> y
.br
= 41
.RE
.PP
Variable names are case-sensitive and can contain letters, numbers, and
underscores (must start with a letter).
.SS Commands
.TP
.B help
Show general help overview
.TP
.B help \fIfunction\fR
Show detailed help for a specific function, including syntax and examples.
Example: \\fBhelp sin\\fR, \\fBhelp pca\\fR, \\fBhelp kmeans\\fR
.TP
.B demo \fIfunction\fR
Run interactive demonstration of a function with live examples.
Example: \\fBdemo svd\\fR, \\fBdemo qr\\fR
.TP
.B vars
List all defined variables
.TP
.B clear \fIname\fR
Clear a specific variable
.TP
.B clearall
Clear all variables
.SH ANGLE MODES
By default, all trigonometric functions use radians. Use these commands to change angle mode:
.TP
.B deg \fRor\fB degrees
Use degrees (360° = full circle)
.TP
.B rad \fRor\fB radians
Use radians (2π = full circle) [default]
.TP
.B grad \fRor\fB gradians
Use gradians (400 grad = full circle)
.PP
The angle mode affects \fBsin\fR, \fBcos\fR, \fBtan\fR, \fBsec\fR, \fBcsc\fR, \fBcot\fR and their inverses, as well as \fBatan2\fR.
.SH FUNCTIONS
This section documents all available functions organized by category.

.SS Angle
.TP
.B deg2rad(x)
Convert degrees to radians
.RS
.nf
deg2rad(180) = pi
deg2rad(90) = pi/2
.fi
.RE
.TP
.B hypot(x, y)
Hypotenuse: sqrt(x^2 + y^2)
.RS
.nf
hypot(3, 4) = 5
.fi
.RE
.TP
.B rad2deg(x)
Convert radians to degrees
.RS
.nf
rad2deg(pi) = 180
rad2deg(pi/2) = 90
.fi
.RE
.TP
.B wrap180(x)
Wrap angle to [-180, 180]
.RS
.nf
wrap180(270) = -90
.fi
.RE
.TP
.B wrap360(x)
Wrap angle to [0, 360)
.RS
.nf
wrap360(370) = 10
wrap360(-10) = 350
.fi
.RE
.TP
.B wrapToPi(x)
Wrap angle to [-pi, pi]
.RS
.nf
wrapToPi(4) = 4-2*pi
.fi
.RE

.SS Bitwise
.TP
.B bitand(a, b)
Bitwise AND
.RS
.nf
bitand(15, 7) = 7
bitand(255, 15) = 15
.fi
.RE
.TP
.B bitor(a, b)
Bitwise OR
.RS
.nf
bitor(8, 4) = 12
bitor(240, 15) = 255
.fi
.RE
.TP
.B bitshift(a, k)
Shift left (k>0) or right (k<0)
.RS
.nf
bitshift(1, 4) = 16
.fi
.RE
.TP
.B bitxor(a, b)
Bitwise XOR
.RS
.nf
bitxor(255, 170) = 85
.fi
.RE
.TP
.B bnot(a) or not(a)
Bitwise NOT
.RS
.nf
bnot(0) = -1
.fi
.RE
.TP
.B shl(a, k)
Shift left by k bits
.RS
.nf
shl(1, 4) = 16
.fi
.RE
.TP
.B shr(a, k)
Shift right by k bits
.RS
.nf
shr(16, 2) = 4
.fi
.RE

.SS Complex
.TP
.B abs(x) or abs(z)
Absolute value or complex magnitude
.RS
.nf
abs(-5) = 5
abs(3+4i) = 5
.fi
.RE
.TP
.B angle(z)
Phase angle in radians (alias for arg)
.RS
.nf
angle(1+i) = pi/4
.fi
.RE
.TP
.B arg(z)
Argument (phase angle) in radians
.RS
.nf
arg(1+i) = pi/4
arg(-1) = pi
.fi
.RE
.TP
.B cart2pol(x, y)
Cartesian to polar: returns [r, theta]
.RS
.nf
cart2pol(3, 4) = [5, 0.927]
.fi
.RE
.TP
.B complex(a, b)
Create complex number a + bi
.RS
.nf
complex(3, 4) = 3+4i
.fi
.RE
.TP
.B conj(z)
Complex conjugate
.RS
.nf
conj(3+4i) = 3-4i
conj(5) = 5
.fi
.RE
.TP
.B im(z) or imag(z)
Imaginary part of complex number
.RS
.nf
im(3+4i) = 4
im(5) = 0
.fi
.RE
.TP
.B imag(z)
Imaginary part (alias for im)
.RS
.nf
imag(3+4i) = 4
.fi
.RE
.TP
.B phase(z)
Phase angle (alias for arg)
.RS
.nf
phase(1+i) = pi/4
.fi
.RE
.TP
.B pol2cart(r, theta)
Polar to Cartesian: returns [x, y]
.RS
.nf
pol2cart(5, 0) = [5, 0]
.fi
.RE
.TP
.B re(z) or real(z)
Real part of complex number
.RS
.nf
re(3+4i) = 3
re(5) = 5
.fi
.RE
.TP
.B real(z)
Real part (alias for re)
.RS
.nf
real(3+4i) = 3
.fi
.RE

.SS Coordinates
.TP
.B cart2sph(x, y, z)
Cartesian to spherical
.RS
.nf
cart2sph(1, 2, 3)
.fi
.RE
.TP
.B sph2cart(az, el, r)
Spherical to Cartesian
.RS
.nf
sph2cart(0, 0, 1)
.fi
.RE

.SS Data Science
.TP
.B corrcoef(X)
Correlation coefficient matrix
.RS
.nf
corrcoef([1,2,3;4,5,6]')
Pairwise correlations
.fi
.RE
.TP
.B cov(X)
Covariance matrix
.RS
.nf
cov([1,2,3;4,5,6]')
.fi
.RE
.TP
.B [idx,C] = kmeans(X, k)
K-means clustering
.RS
.nf
[idx,C] = kmeans(X, 3)
idx=cluster labels, C=centroids
scatter with color: idx gives cluster
.fi
.RE
.TP
.B normalize(X)
Normalize rows to unit length
.RS
.nf
normalize([3,4;1,0])
Each row has norm=1
.fi
.RE
.TP
.B [coeff,score,latent] = pca(X)
Principal Component Analysis
.RS
.nf
X = rand(100,5); [C,S,L] = pca(X)
C=coeffs, S=scores, L=variance
score = (X - mean(X)) * coeff
.fi
.RE
.TP
.B pcareduce(X, k)
Reduce data to k principal components
.RS
.nf
Y = pcareduce(X, 2)
Reduce to 2D for visualization
Example: X=rand(50,10); plot(pcareduce(X,2))
.fi
.RE
.TP
.B pdist(X)
Pairwise distances between rows
.RS
.nf
pdist([0,0;1,0;0,1])
Returns distance vector
.fi
.RE
.TP
.B silhouette(X, idx)
Clustering quality score
.RS
.nf
silhouette(X, idx)
Higher is better (max 1)
.fi
.RE
.TP
.B zscore(X)
Standardize columns to mean=0, std=1
.RS
.nf
zscore([1,2,3;4,5,6])
Each column normalized
.fi
.RE

.SS Exponential
.TP
.B cbrt(x)
Cube root
.RS
.nf
cbrt(8) = 2
cbrt(27) = 3
cbrt(-8) = -2
.fi
.RE
.TP
.B exp(x)
Exponential function e^x
.RS
.nf
exp(0) = 1
exp(1) = e = 2.718...
exp(ln(5)) = 5
.fi
.RE
.TP
.B exp2(x)
Base-2 exponential: 2^x
.RS
.nf
exp2(0) = 1
exp2(10) = 1024
.fi
.RE
.TP
.B expm1(x)
exp(x)-1, accurate for small x
.RS
.nf
expm1(0) = 0
expm1(1) = e-1
.fi
.RE
.TP
.B ln(x)
Natural logarithm (base e)
.RS
.nf
ln(1) = 0
ln(e) = 1
ln(exp(5)) = 5
.fi
.RE
.TP
.B log(x)
Natural logarithm (alias for ln)
.RS
.nf
log(1) = 0
log(e) = 1
.fi
.RE
.TP
.B log10(x)
Base-10 logarithm
.RS
.nf
log10(1) = 0
log10(10) = 1
log10(1000) = 3
.fi
.RE
.TP
.B log1p(x)
log(1+x), accurate for small x
.RS
.nf
log1p(0) = 0
log1p(1) = ln(2)
.fi
.RE
.TP
.B log2(x)
Base-2 logarithm
.RS
.nf
log2(1) = 0
log2(8) = 3
log2(1024) = 10
.fi
.RE
.TP
.B nthroot(x, n)
n-th root of x
.RS
.nf
nthroot(16, 4) = 2
nthroot(32, 5) = 2
.fi
.RE
.TP
.B x^y or pow(x,y)
x raised to power y
.RS
.nf
2^10 = 1024
3^4 = 81
(-1)^0.5 = i
.fi
.RE
.TP
.B reallog(x)
Real-valued logarithm (error for x<=0)
.RS
.nf
reallog(e) = 1
reallog(10) = 2.303
.fi
.RE
.TP
.B realpow(x, y)
Real-valued power
.RS
.nf
realpow(2, 3) = 8
.fi
.RE
.TP
.B realsqrt(x)
Real-valued sqrt (error for x<0)
.RS
.nf
realsqrt(4) = 2
realsqrt(2) = 1.414
.fi
.RE
.TP
.B sqrt(x)
Square root
.RS
.nf
sqrt(4) = 2
sqrt(2) = 1.414...
sqrt(-1) = i
.fi
.RE

.SS Linear Algebra
.TP
.B chol(A) or [L] = chol(A)
Cholesky decomposition (A = L*L')
.RS
.nf
chol([4,2;2,5])
For positive definite matrices
.fi
.RE
.TP
.B cond(A)
Condition number
.RS
.nf
cond([1,2;3,4])
.fi
.RE
.TP
.B det(A)
Matrix determinant
.RS
.nf
det([1,2;3,4]) = -2
det(eye(3)) = 1
.fi
.RE
.TP
.B eig(A) or [V,D] = eig(A)
Eigenvalues/eigenvectors
.RS
.nf
[V,D] = eig([1,2;2,1])
A*V = V*D, D=diag of eigenvalues
.fi
.RE
.TP
.B inv(A)
Matrix inverse
.RS
.nf
inv([1,2;3,4])
A * inv(A) = eye
.fi
.RE
.TP
.B linsolve(A, b)
Solve Ax = b
.RS
.nf
linsolve([1,2;3,4], [5;6])
.fi
.RE
.TP
.B [L,U] = lu(A) or [L,U,P] = lu(A)
LU factorization
.RS
.nf
[L,U] = lu([1,2;3,4])
L*U = P*A
.fi
.RE
.TP
.B A \\\\ b or mldivide(A, b)
Matrix left division
.RS
.nf
[1,2;3,4] \\\\ [5;6]
.fi
.RE
.TP
.B norm(v) or norm(A)
Vector/matrix norm
.RS
.nf
norm([3,4]) = 5
norm([1,2;3,4])
.fi
.RE
.TP
.B null(A)
Null space basis vectors
.RS
.nf
null([1,2,3;2,4,6])
Returns basis for Ax=0
.fi
.RE
.TP
.B [Q,R] = qr(A)
QR factorization (A = Q*R)
.RS
.nf
[Q,R] = qr([1,2;3,4])
Q*R = A
.fi
.RE
.TP
.B rank(A)
Matrix rank
.RS
.nf
rank([1,2;3,4]) = 2
rank([1,2;2,4]) = 1
.fi
.RE
.TP
.B [Q,T] = schur(A)
Schur decomposition (A = Q*T*Q')
.RS
.nf
[Q,T] = schur([1,2;3,4])
T upper triangular
.fi
.RE
.TP
.B [U,S,V] = svd(A)
Singular value decomposition (A = U*S*V')
.RS
.nf
[U,S,V] = svd([1,2;3,4])
U*S*V' = A
.fi
.RE
.TP
.B trace(A)
Sum of diagonal elements
.RS
.nf
trace([1,2;3,4]) = 5
trace(eye(n)) = n
.fi
.RE
.TP
.B trans(A) or A'
Matrix transpose
.RS
.nf
trans([1,2;3,4]) = [1,3;2,4]
[1,2,3]' = column
.fi
.RE

.SS Logical
.TP
.B all(v)
True if all elements are nonzero
.RS
.nf
all([1,1,1]) = true
all([1,0,1]) = false
.fi
.RE
.TP
.B any(v)
True if any element is nonzero
.RS
.nf
any([0,0,1]) = true
any([0,0,0]) = false
.fi
.RE
.TP
.B eq(a, b)
Element-wise equality
.RS
.nf
eq(5, 5) = 1
5 == 5 = true
.fi
.RE
.TP
.B ge(a, b)
Greater than or equal
.RS
.nf
ge(5, 5) = 1
5 >= 5 = true
.fi
.RE
.TP
.B gt(a, b)
Greater than
.RS
.nf
gt(6, 5) = 1
6 > 5 = true
.fi
.RE
.TP
.B isfinite(x)
Test if finite
.RS
.nf
isfinite(1) = true
isfinite(Inf) = false
.fi
.RE
.TP
.B isinf(x)
Test if infinite
.RS
.nf
isinf(Inf) = true
isinf(1) = false
.fi
.RE
.TP
.B isnan(x)
Test if NaN
.RS
.nf
isnan(NaN) = true
isnan(1) = false
.fi
.RE
.TP
.B isreal(x)
Test if real (no imaginary part)
.RS
.nf
isreal(5) = true
isreal(5+3i) = false
.fi
.RE
.TP
.B le(a, b)
Less than or equal
.RS
.nf
le(5, 5) = 1
5 <= 5 = true
.fi
.RE
.TP
.B lt(a, b)
Less than
.RS
.nf
lt(5, 6) = 1
5 < 6 = true
.fi
.RE
.TP
.B ne(a, b)
Element-wise not-equal
.RS
.nf
ne(5, 6) = 1
5 ~= 6 = true
.fi
.RE

.SS Matrix
.TP
.B blkdiag(A, B, ...)
Block diagonal matrix
.RS
.nf
blkdiag([1,2;3,4], [5,6;7,8])
.fi
.RE
.TP
.B cat(dim, A, B)
Concatenate along dimension
.RS
.nf
cat(1, [1,2], [3,4])
.fi
.RE
.TP
.B circshift(v, k)
Circular shift by k positions
.RS
.nf
circshift([1,2,3,4], 1) = [4,1,2,3]
.fi
.RE
.TP
.B compan(p)
Companion matrix of polynomial
.RS
.nf
compan([1,-6,11,-6])
.fi
.RE
.TP
.B diag(v) or diag(A)
Create diagonal or extract diagonal
.RS
.nf
diag([1,2,3]) = 3x3 diagonal
diag(A) = diagonal of A
.fi
.RE
.TP
.B eye(n) or eye(m,n)
Identity matrix
.RS
.nf
eye(3) = 3x3 identity
.fi
.RE
.TP
.B flip(v)
Flip vector/matrix
.RS
.nf
flip([1,2,3]) = [3,2,1]
.fi
.RE
.TP
.B fliplr(A)
Flip matrix left-right
.RS
.nf
fliplr([1,2,3]) = [3,2,1]
.fi
.RE
.TP
.B flipud(A)
Flip matrix up-down
.RS
.nf
flipud([1;2;3]) = [3;2;1]
.fi
.RE
.TP
.B hankel(v)
Hankel matrix
.RS
.nf
hankel([1,2,3])
.fi
.RE
.TP
.B hilb(n)
n x n Hilbert matrix
.RS
.nf
hilb(3) = ill-conditioned matrix
.fi
.RE
.TP
.B horzcat(A, B) or [A, B]
Horizontal concatenation
.RS
.nf
horzcat([1;2], [3;4])
.fi
.RE
.TP
.B linspace(a, b, n)
n linearly spaced points from a to b
.RS
.nf
linspace(0, 10, 5) = [0,2.5,5,7.5,10]
.fi
.RE
.TP
.B logspace(a, b, n)
n log-spaced points: 10^a to 10^b
.RS
.nf
logspace(0, 2, 3) = [1, 10, 100]
.fi
.RE
.TP
.B magic(n)
n x n magic square
.RS
.nf
magic(3) = 3x3 magic square
.fi
.RE
.TP
.B ones(n) or ones(m,n)
Matrix of ones
.RS
.nf
ones(3) = 3x3 ones
ones(2,3) = 2x3 ones
.fi
.RE
.TP
.B pascal(n)
n x n Pascal matrix
.RS
.nf
pascal(4)
.fi
.RE
.TP
.B repmat(A, m, n)
Tile A into m x n copies
.RS
.nf
repmat([1,2], 2, 3)
.fi
.RE
.TP
.B reshape(A, m, n)
Reshape matrix to m x n
.RS
.nf
reshape([1:6], 2, 3)
.fi
.RE
.TP
.B rot90(A) or rot90(A, k)
Rotate matrix 90 degrees k times
.RS
.nf
rot90([1,2;3,4])
.fi
.RE
.TP
.B sort(v)
Sort elements ascending
.RS
.nf
sort([3,1,4,1,5]) = [1,1,3,4,5]
.fi
.RE
.TP
.B sortrows(A)
Sort rows of matrix
.RS
.nf
sortrows([3,1;1,4;2,2])
.fi
.RE
.TP
.B toeplitz(v)
Symmetric Toeplitz matrix
.RS
.nf
toeplitz([1,2,3])
.fi
.RE
.TP
.B tril(A)
Lower triangular part
.RS
.nf
tril([1,2;3,4]) = [1,0;3,4]
.fi
.RE
.TP
.B triu(A)
Upper triangular part
.RS
.nf
triu([1,2;3,4]) = [1,2;0,4]
.fi
.RE
.TP
.B unique(v)
Unique elements sorted
.RS
.nf
unique([1,2,2,3,3,3]) = [1,2,3]
.fi
.RE
.TP
.B vander(v)
Vandermonde matrix
.RS
.nf
vander([1,2,3])
.fi
.RE
.TP
.B vertcat(A, B) or [A; B]
Vertical concatenation
.RS
.nf
vertcat([1,2], [3,4])
.fi
.RE
.TP
.B zeros(n) or zeros(m,n)
Matrix of zeros
.RS
.nf
zeros(3) = 3x3 zeros
zeros(2,3) = 2x3 zeros
.fi
.RE

.SS Matrix Query
.TP
.B cols(A)
Number of columns
.RS
.nf
cols([1,2,3;4,5,6]) = 3
.fi
.RE
.TP
.B iscolumn(A)
Test if column vector
.RS
.nf
iscolumn([1;2;3]) = true
.fi
.RE
.TP
.B isempty(A)
Test if empty
.RS
.nf
isempty([]) = true
isempty([1]) = false
.fi
.RE
.TP
.B ismatrix(A)
Test if 2D matrix
.RS
.nf
ismatrix([1,2;3,4]) = true
.fi
.RE
.TP
.B isrow(A)
Test if row vector
.RS
.nf
isrow([1,2,3]) = true
.fi
.RE
.TP
.B isscalar(x)
Test if scalar (1x1)
.RS
.nf
isscalar(5) = true
isscalar([1,2]) = false
.fi
.RE
.TP
.B issorted(v)
Test if sorted ascending
.RS
.nf
issorted([1,2,3]) = true
.fi
.RE
.TP
.B issquare(A)
Test if square matrix
.RS
.nf
issquare([1,2;3,4]) = true
.fi
.RE
.TP
.B issymmetric(A)
Test if symmetric
.RS
.nf
issymmetric([1,2;2,1]) = true
.fi
.RE
.TP
.B isvector(A)
Test if row or column vector
.RS
.nf
isvector([1,2,3]) = true
.fi
.RE
.TP
.B length(v)
Length of vector
.RS
.nf
length([1,2,3,4,5]) = 5
.fi
.RE
.TP
.B ndims(A)
Number of dimensions
.RS
.nf
ndims([1,2,3;4,5,6]) = 2
.fi
.RE
.TP
.B numel(A)
Number of elements
.RS
.nf
numel([1,2,3;4,5,6]) = 6
.fi
.RE
.TP
.B rows(A)
Number of rows
.RS
.nf
rows([1,2,3;4,5,6]) = 2
.fi
.RE
.TP
.B size(A)
Dimensions [rows, cols]
.RS
.nf
size([1,2,3;4,5,6]) = [2, 3]
.fi
.RE

.SS Number Theory
.TP
.B catalan(n)
n-th Catalan number
.RS
.nf
catalan(0) = 1
catalan(5) = 42
catalan(10) = 16796
.fi
.RE
.TP
.B divisors(n)
List all divisors of n
.RS
.nf
divisors(12) = [1,2,3,4,6,12]
.fi
.RE
.TP
.B even(n)
Test if n is even
.RS
.nf
even(4) = true
even(5) = false
.fi
.RE
.TP
.B fact(n) or factorial(n)
Factorial n!
.RS
.nf
fact(5) = 120
fact(0) = 1
fact(10) = 3628800
.fi
.RE
.TP
.B factorial(n)
Factorial n! (alias for fact)
.RS
.nf
factorial(5) = 120
.fi
.RE
.TP
.B factorial2(n)
Double factorial n!!
.RS
.nf
factorial2(10) = 3840
factorial2(9) = 945
.fi
.RE
.TP
.B fibonacci(n)
n-th Fibonacci number
.RS
.nf
fibonacci(0) = 0
fibonacci(10) = 55
fibonacci(20) = 6765
.fi
.RE
.TP
.B gamma(x)
Gamma function: (x-1)! for integers
.RS
.nf
gamma(5) = 24
gamma(0.5) = sqrt(pi)
.fi
.RE
.TP
.B gcd(a, b)
Greatest common divisor
.RS
.nf
gcd(12, 18) = 6
gcd(48, 18) = 6
.fi
.RE
.TP
.B isprime(n)
Test if n is prime
.RS
.nf
isprime(7) = true
isprime(8) = false
isprime(2) = true
.fi
.RE
.TP
.B lcm(a, b)
Least common multiple
.RS
.nf
lcm(4, 6) = 12
lcm(12, 18) = 36
.fi
.RE
.TP
.B lgamma(x)
Log-gamma function: ln(gamma(x))
.RS
.nf
lgamma(5) = ln(24)
lgamma(10) = 12.802
.fi
.RE
.TP
.B lucas(n)
n-th Lucas number
.RS
.nf
lucas(0) = 2
lucas(1) = 1
lucas(10) = 123
.fi
.RE
.TP
.B mobius(n)
Mobius function mu(n)
.RS
.nf
mobius(1) = 1
mobius(6) = 1
mobius(4) = 0
.fi
.RE
.TP
.B ncr(n, r)
Binomial coefficient C(n,r) = n!/(r!(n-r)!)
.RS
.nf
ncr(5, 2) = 10
ncr(10, 3) = 120
.fi
.RE
.TP
.B npr(n, r)
Permutations P(n,r) = n!/(n-r)!
.RS
.nf
npr(5, 2) = 20
npr(10, 3) = 720
.fi
.RE
.TP
.B odd(n)
Test if n is odd
.RS
.nf
odd(5) = true
odd(4) = false
.fi
.RE
.TP
.B totient(n)
Euler's totient function phi(n)
.RS
.nf
totient(10) = 4
totient(12) = 4
.fi
.RE

.SS Polynomial
.TP
.B polyder(p)
Polynomial derivative
.RS
.nf
polyder([1,2,3]) = [2,2]
.fi
.RE
.TP
.B polyint(p)
Polynomial integral
.RS
.nf
polyint([2,2]) = [1,2,0]
.fi
.RE
.TP
.B polyval(p, x)
Evaluate polynomial p at x
.RS
.nf
polyval([1,2,3], 2) = 11
p = [1,2,3] means x^2+2x+3
.fi
.RE

.SS Probability
.TP
.B chi2cdf(x, df)
Chi-squared cumulative distribution
.RS
.nf
chi2cdf(0, 5) = 0
chi2cdf(11.07, 5) = 0.95
.fi
.RE
.TP
.B normcdf(x) or normcdf(x,mu,sigma)
Normal CDF
.RS
.nf
normcdf(0) = 0.5
normcdf(1.96) = 0.975
.fi
.RE
.TP
.B norminv(p)
Inverse normal CDF (quantile)
.RS
.nf
norminv(0.5) = 0
norminv(0.975) = 1.96
.fi
.RE
.TP
.B normpdf(x) or normpdf(x,mu,sigma)
Normal PDF
.RS
.nf
normpdf(0) = 0.399
normpdf(0, 0, 1) = 0.399
.fi
.RE
.TP
.B rand or rand(n) or rand(m,n)
Uniform random [0,1)
.RS
.nf
rand = random scalar
rand(3) = 3x3 random matrix
.fi
.RE
.TP
.B randi(max) or randi(max,n)
Random integer [1,max]
.RS
.nf
randi(6) = dice roll
randi(10, 3) = 3x3 ints
.fi
.RE
.TP
.B randn or randn(n) or randn(m,n)
Standard normal random
.RS
.nf
randn = random scalar N(0,1)
randn(3) = 3x3 random matrix
.fi
.RE
.TP
.B randperm(n)
Random permutation of 1:n
.RS
.nf
randperm(5) = shuffled [1,2,3,4,5]
.fi
.RE
.TP
.B tcdf(t, df)
Student's t cumulative distribution
.RS
.nf
tcdf(0, 10) = 0.5
tcdf(1.812, 10) = 0.95
.fi
.RE

.SS Rounding
.TP
.B ceil(x)
Round toward positive infinity
.RS
.nf
ceil(3.2) = 4
ceil(-3.2) = -3
.fi
.RE
.TP
.B fix(x)
Round toward zero (alias for trunc)
.RS
.nf
fix(3.7) = 3
fix(-3.7) = -3
.fi
.RE
.TP
.B floor(x)
Round toward negative infinity
.RS
.nf
floor(3.7) = 3
floor(-3.7) = -4
.fi
.RE
.TP
.B frac(x)
Fractional part: x - trunc(x)
.RS
.nf
frac(3.7) = 0.7
frac(-3.7) = -0.7
.fi
.RE
.TP
.B mod(x, y)
Modulo (floored division remainder)
.RS
.nf
mod(17, 5) = 2
mod(-17, 5) = 3
.fi
.RE
.TP
.B rem(x, y)
Remainder (truncated division)
.RS
.nf
rem(17, 5) = 2
rem(-17, 5) = -2
.fi
.RE
.TP
.B round(x)
Round to nearest integer
.RS
.nf
round(3.5) = 4
round(3.4) = 3
round(-3.5) = -4
.fi
.RE
.TP
.B sign(x)
Sign function: -1, 0, or 1
.RS
.nf
sign(5) = 1
sign(-5) = -1
sign(0) = 0
.fi
.RE
.TP
.B signum(x)
Sign function (alias for sign)
.RS
.nf
signum(5) = 1
.fi
.RE
.TP
.B trunc(x)
Round toward zero
.RS
.nf
trunc(3.7) = 3
trunc(-3.7) = -3
.fi
.RE

.SS Set
.TP
.B intersect(A, B)
Set intersection
.RS
.nf
intersect([1,2,3], [2,3,4]) = [2,3]
.fi
.RE
.TP
.B setdiff(A, B)
Set difference: A - B
.RS
.nf
setdiff([1,2,3], [2,3,4]) = [1]
.fi
.RE
.TP
.B setxor(A, B)
Symmetric difference
.RS
.nf
setxor([1,2,3], [2,3,4]) = [1,4]
.fi
.RE
.TP
.B union(A, B)
Set union
.RS
.nf
union([1,2,3], [2,3,4]) = [1,2,3,4]
.fi
.RE

.SS Signal
.TP
.B conv(u, v)
Convolution of vectors
.RS
.nf
conv([1,2,3], [1,1]) = [1,3,5,3]
.fi
.RE
.TP
.B corrcoef(x, y)
Correlation coefficient
.RS
.nf
corrcoef([1,2,3], [2,4,6]) = 1
.fi
.RE
.TP
.B cumprod(v)
Cumulative product
.RS
.nf
cumprod([1,2,3,4,5]) = [1,2,6,24,120]
.fi
.RE
.TP
.B cumsum(v)
Cumulative sum
.RS
.nf
cumsum([1,2,3,4,5]) = [1,3,6,10,15]
.fi
.RE
.TP
.B deconv(u, v)
Deconvolution
.RS
.nf
deconv([1,3,5,3], [1,1])
.fi
.RE
.TP
.B diff(v)
Differences between consecutive elements
.RS
.nf
diff([1,4,9,16]) = [3,5,7]
.fi
.RE
.TP
.B gradient(v)
Numerical gradient
.RS
.nf
gradient([1,4,9,16,25])
.fi
.RE
.TP
.B interp1(x, y, xi)
Linear interpolation
.RS
.nf
interp1([1,2,3], [1,4,9], 1.5) = 2.5
.fi
.RE
.TP
.B movmean(v, k)
Moving average with window k
.RS
.nf
movmean([1,2,3,4,5], 3)
.fi
.RE
.TP
.B movsum(v, k)
Moving sum with window k
.RS
.nf
movsum([1,2,3,4,5], 3)
.fi
.RE
.TP
.B trapz(y) or trapz(x, y)
Trapezoidal integration
.RS
.nf
trapz([1,2,3,4,5])
.fi
.RE

.SS Special
.TP
.B besselj(n, x)
Bessel function of first kind J_n(x)
.RS
.nf
besselj(0, 1) = 0.765
besselj(1, 1) = 0.440
.fi
.RE
.TP
.B bessely(n, x)
Bessel function of second kind Y_n(x)
.RS
.nf
bessely(0, 1) = 0.088
bessely(1, 1) = -0.781
.fi
.RE
.TP
.B beta(a, b)
Beta function: gamma(a)*gamma(b)/gamma(a+b)
.RS
.nf
beta(2, 3) = 0.0833
beta(1, 1) = 1
.fi
.RE
.TP
.B digamma(x) or psi(x)
Digamma function: d/dx ln(Gamma(x))
.RS
.nf
digamma(1) = -0.5772 (Euler-Mascheroni)
.fi
.RE
.TP
.B erf(x)
Error function
.RS
.nf
erf(0) = 0
erf(1) = 0.843
erf(inf) = 1
.fi
.RE
.TP
.B erfc(x)
Complementary error function: 1-erf(x)
.RS
.nf
erfc(0) = 1
erfc(1) = 0.157
.fi
.RE
.TP
.B harmonic(n)
Harmonic number H_n = 1 + 1/2 + ... + 1/n
.RS
.nf
harmonic(1) = 1
harmonic(10) = 2.9289
.fi
.RE
.TP
.B heaviside(x)
Heaviside step function
.RS
.nf
heaviside(1) = 1
heaviside(-1) = 0
.fi
.RE
.TP
.B rect(x)
Rectangle function: 1 if |x|<0.5
.RS
.nf
rect(0) = 1
rect(0.6) = 0
.fi
.RE
.TP
.B sigmoid(x)
Logistic sigmoid: 1/(1+exp(-x))
.RS
.nf
sigmoid(0) = 0.5
sigmoid(10) = 0.9999...
.fi
.RE
.TP
.B softplus(x)
Softplus: ln(1+exp(x))
.RS
.nf
softplus(0) = ln(2)
softplus(10) = 10
.fi
.RE
.TP
.B step(x) or heaviside(x)
Unit step function
.RS
.nf
step(1) = 1
step(-1) = 0
step(0) = 0.5
.fi
.RE
.TP
.B tri(x)
Triangle function: max(0, 1-|x|)
.RS
.nf
tri(0) = 1
tri(0.5) = 0.5
tri(1) = 0
.fi
.RE
.TP
.B zeta(s)
Riemann zeta function for s > 1
.RS
.nf
zeta(2) = pi^2/6 = 1.6449
zeta(4) = pi^4/90
.fi
.RE

.SS Statistics
.TP
.B geomean(v)
Geometric mean
.RS
.nf
geomean([1,2,4,8]) = 2.828
.fi
.RE
.TP
.B harmmean(v)
Harmonic mean
.RS
.nf
harmmean([1,2,4]) = 1.714
.fi
.RE
.TP
.B iqr(v)
Interquartile range: Q3-Q1
.RS
.nf
iqr([1,2,3,4,5,6,7,8,9,10])
.fi
.RE
.TP
.B kurtosis(v)
Sample kurtosis
.RS
.nf
kurtosis([1,2,3,4,5])
.fi
.RE
.TP
.B mad(v)
Mean absolute deviation
.RS
.nf
mad([1,2,3,4,5]) = 1.2
.fi
.RE
.TP
.B max(v) or max(a,b,...)
Maximum value
.RS
.nf
max([3,1,4,1,5]) = 5
max(3, 7) -> use max([3,7])
.fi
.RE
.TP
.B mean(v)
Arithmetic mean
.RS
.nf
mean([1,2,3,4,5]) = 3
.fi
.RE
.TP
.B meansq(v)
Mean of squares
.RS
.nf
meansq([1,2,3]) = 4.667
.fi
.RE
.TP
.B median(v)
Median value
.RS
.nf
median([1,2,3,4,5]) = 3
median([1,2,3,4]) = 2.5
.fi
.RE
.TP
.B min(v) or min(a,b,...)
Minimum value
.RS
.nf
min([3,1,4,1,5]) = 1
min(3, 7) -> use min([3,7])
.fi
.RE
.TP
.B prctile(v, p)
p-th percentile
.RS
.nf
prctile([1:10], 50) = median
.fi
.RE
.TP
.B range(v)
Range: max - min
.RS
.nf
range([1,2,3,4,5]) = 4
.fi
.RE
.TP
.B rms(v)
Root mean square
.RS
.nf
rms([3,4]) = 3.536
.fi
.RE
.TP
.B skewness(v)
Sample skewness
.RS
.nf
skewness([1,2,3,4,5]) = 0
.fi
.RE
.TP
.B std(v)
Sample standard deviation
.RS
.nf
std([1,2,3,4,5]) = 1.581
.fi
.RE
.TP
.B sum(v)
Sum of vector elements
.RS
.nf
sum([1,2,3,4,5]) = 15
.fi
.RE
.TP
.B sumsq(v)
Sum of squares
.RS
.nf
sumsq([1,2,3]) = 14
.fi
.RE
.TP
.B var(v)
Sample variance
.RS
.nf
var([1,2,3,4,5]) = 2.5
.fi
.RE
.TP
.B zscore(v)
Standardized z-scores
.RS
.nf
zscore([1,2,3,4,5])
.fi
.RE

.SS Text
.TP
.B bow(str)
Bag of words - tokenize string to word counts
.RS
.nf
bow('hello world hello')
Returns [hello:2, world:1]
.fi
.RE
.TP
.B tfidf(docs)
TF-IDF weighting for document matrix
.RS
.nf
D = [bow('cat dog'); bow('dog bird')]; tfidf(D)
.fi
.RE
.TP
.B wordvec(vocab, str)
Convert string to word vector using vocabulary
.RS
.nf
v = ['cat','dog','bird']; wordvec(v,'cat dog')
Returns [1,1,0]
.fi
.RE

.SS Trigonometry
.TP
.B acos(x)
Inverse cosine, returns radians. Domain: [-1, 1]
.RS
.nf
acos(1) = 0
acos(0.5) = pi/3
acos(0) = pi/2
.fi
.RE
.TP
.B acosd(x)
Inverse cosine, returns degrees
.RS
.nf
acosd(1) = 0
acosd(0.5) = 60
acosd(0) = 90
.fi
.RE
.TP
.B acosh(x)
Inverse hyperbolic cosine. Domain: [1, inf)
.RS
.nf
acosh(1) = 0
acosh(2) = 1.317
.fi
.RE
.TP
.B acot(x)
Inverse cotangent
.RS
.nf
acot(1) = pi/4
acot(0) = pi/2
.fi
.RE
.TP
.B acoth(x)
Inverse hyperbolic cotangent. Domain: |x| > 1
.RS
.nf
acoth(2) = 0.549
.fi
.RE
.TP
.B acsc(x)
Inverse cosecant. Domain: |x| >= 1
.RS
.nf
acsc(1) = pi/2
acsc(2) = pi/6
.fi
.RE
.TP
.B acsch(x)
Inverse hyperbolic cosecant
.RS
.nf
acsch(1) = 0.881
.fi
.RE
.TP
.B asec(x)
Inverse secant. Domain: |x| >= 1
.RS
.nf
asec(1) = 0
asec(2) = pi/3
.fi
.RE
.TP
.B asech(x)
Inverse hyperbolic secant. Domain: (0, 1]
.RS
.nf
asech(1) = 0
asech(0.5) = 1.317
.fi
.RE
.TP
.B asin(x)
Inverse sine, returns radians. Domain: [-1, 1]
.RS
.nf
asin(0) = 0
asin(0.5) = pi/6
asin(1) = pi/2
.fi
.RE
.TP
.B asind(x)
Inverse sine, returns degrees
.RS
.nf
asind(0) = 0
asind(0.5) = 30
asind(1) = 90
.fi
.RE
.TP
.B asinh(x)
Inverse hyperbolic sine
.RS
.nf
asinh(0) = 0
asinh(1) = 0.881
.fi
.RE
.TP
.B atan(x)
Inverse tangent, returns radians
.RS
.nf
atan(0) = 0
atan(1) = pi/4
.fi
.RE
.TP
.B atan2(y, x)
Two-argument arctangent, returns angle in radians
.RS
.nf
atan2(1, 1) = pi/4
atan2(1, 0) = pi/2
atan2(-1, -1) = -3*pi/4
.fi
.RE
.TP
.B atan2d(y, x)
Two-argument arctangent, returns degrees
.RS
.nf
atan2d(1, 1) = 45
atan2d(1, 0) = 90
.fi
.RE
.TP
.B atand(x)
Inverse tangent, returns degrees
.RS
.nf
atand(0) = 0
atand(1) = 45
.fi
.RE
.TP
.B atanh(x)
Inverse hyperbolic tangent. Domain: (-1, 1)
.RS
.nf
atanh(0) = 0
atanh(0.5) = 0.549
.fi
.RE
.TP
.B cos(x)
Cosine of x (x in radians)
.RS
.nf
cos(0) = 1
cos(pi/3) = 0.5
cos(pi) = -1
.fi
.RE
.TP
.B cosd(x)
Cosine of x degrees
.RS
.nf
cosd(0) = 1
cosd(60) = 0.5
cosd(90) = 0
.fi
.RE
.TP
.B cosh(x)
Hyperbolic cosine
.RS
.nf
cosh(0) = 1
cosh(1) = 1.543
.fi
.RE
.TP
.B cot(x)
Cotangent: 1/tan(x)
.RS
.nf
cot(pi/4) = 1
cot(pi/2) = 0
.fi
.RE
.TP
.B coth(x)
Hyperbolic cotangent: 1/tanh(x)
.RS
.nf
coth(1) = 1.313
.fi
.RE
.TP
.B csc(x)
Cosecant: 1/sin(x)
.RS
.nf
csc(pi/2) = 1
csc(pi/6) = 2
.fi
.RE
.TP
.B csch(x)
Hyperbolic cosecant: 1/sinh(x)
.RS
.nf
csch(1) = 0.851
.fi
.RE
.TP
.B sec(x)
Secant: 1/cos(x)
.RS
.nf
sec(0) = 1
sec(pi/3) = 2
.fi
.RE
.TP
.B sech(x)
Hyperbolic secant: 1/cosh(x)
.RS
.nf
sech(0) = 1
sech(1) = 0.648
.fi
.RE
.TP
.B sin(x)
Sine of x (x in radians)
.RS
.nf
sin(0) = 0
sin(pi/2) = 1
sin(pi/6) = 0.5
.fi
.RE
.TP
.B sinc(x)
Normalized sinc: sin(pi*x)/(pi*x), sinc(0)=1
.RS
.nf
sinc(0) = 1
sinc(1) = 0
sinc(0.5) = 0.637
.fi
.RE
.TP
.B sind(x)
Sine of x degrees
.RS
.nf
sind(0) = 0
sind(30) = 0.5
sind(90) = 1
.fi
.RE
.TP
.B sinh(x)
Hyperbolic sine
.RS
.nf
sinh(0) = 0
sinh(1) = 1.175
.fi
.RE
.TP
.B tan(x)
Tangent of x (x in radians)
.RS
.nf
tan(0) = 0
tan(pi/4) = 1
.fi
.RE
.TP
.B tand(x)
Tangent of x degrees
.RS
.nf
tand(0) = 0
tand(45) = 1
.fi
.RE
.TP
.B tanh(x)
Hyperbolic tangent
.RS
.nf
tanh(0) = 0
tanh(1) = 0.762
.fi
.RE

.SS Utility
.TP
.B clamp(x, lo, hi)
Clamp x to range [lo, hi]
.RS
.nf
clamp(5, 0, 10) = 5
clamp(-5, 0, 10) = 0
clamp(15, 0, 10) = 10
.fi
.RE
.TP
.B eps
Machine epsilon (smallest x where 1+x > 1)
.RS
.nf
eps = 2.22e-16 (double)
.fi
.RE
.TP
.B find(v)
Indices of nonzero elements
.RS
.nf
find([0,1,0,1,0]) = [2,4]
.fi
.RE
.TP
.B nextpow2(n)
Exponent of next power of 2
.RS
.nf
nextpow2(5) = 3
nextpow2(9) = 4
.fi
.RE
.TP
.B normalize(v)
Normalize to unit length
.RS
.nf
normalize([3,4]) = [0.6, 0.8]
.fi
.RE
.TP
.B realmax
Largest finite floating-point number
.RS
.nf
realmax = 1.79e+308 (double)
.fi
.RE
.TP
.B realmin
Smallest positive normalized number
.RS
.nf
realmin = 2.22e-308 (double)
.fi
.RE
.TP
.B rescale(v)
Scale to [0, 1]
.RS
.nf
rescale([1,2,3,4,5])
.fi
.RE

.SH MATRICES
Matrices are entered using square brackets with semicolons separating rows:
.PP
.RS
>>> A = [1 2; 3 4]
.br
>>> B = [5 6; 7 8]
.br
>>> A * B
.br
   19   22
.br
   43   50
.RE
.SS Matrix Creation Functions
.TP
.B zeros(n) \fRor\fB zeros(m, n)
Matrix of zeros
.TP
.B ones(n) \fRor\fB ones(m, n)
Matrix of ones
.TP
.B eye(n)
Identity matrix
.TP
.B rand(n) \fRor\fB rand(m, n)
Random matrix (uniform 0-1)
.TP
.B randn(n) \fRor\fB randn(m, n)
Random matrix (standard normal)
.TP
.B randi(max, m, n)
Random integers 1 to max
.TP
.B randi(min, max, m, n)
Random integers min to max
.SS Matrix Operations
.TP
.B A + B, A - B
Element-wise addition/subtraction
.TP
.B A * B
Matrix multiplication
.TP
.B A .* B
Element-wise multiplication
.TP
.B A ./ B
Element-wise division
.TP
.B A .^ n
Element-wise power
.TP
.B A'
Transpose
.TP
.B A \\\\ B
Left division (solve AX = B)
.TP
.B A / B
Right division (solve XB = A)
.SS Matrix Functions
.TP
.B det(A)
Determinant
.TP
.B inv(A)
Inverse
.TP
.B trace(A)
Sum of diagonal elements
.TP
.B size(A)
Dimensions [rows cols]
.TP
.B lu(A)
LU decomposition (prints L and U)
.SS Matrix Indexing
.TP
.B A(i, j)
Element at row i, column j (1-indexed)
.TP
.B A(i, :)
Row i
.TP
.B A(:, j)
Column j
.SH STATISTICS
.SS Data Entry
.TP
.B data+ \fIx\fR
Add single data point
.TP
.B data+ \fIx y\fR
Add paired data point (for regression)
.TP
.B data- \fIx\fR
Remove data point
.SS Statistical Commands
.TP
.B stat
Show summary (n, Σx, mean, median, sdev, r)
.TP
.B stat clear
Clear all data
.TP
.B stat mean
Arithmetic mean
.TP
.B stat median
Median (middle value)
.TP
.B stat sdev \fRor\fB stat sd
Sample standard deviation
.TP
.B stat var
Sample variance
.TP
.B stat sum
Sum of all values
.TP
.B stat n \fRor\fB stat count
Number of data points
.SS Regression (requires paired data)
.TP
.B stat corr \fRor\fB stat r
Pearson correlation coefficient
.TP
.B stat slope \fRor\fB stat m
Regression line slope
.TP
.B stat intercept \fRor\fB stat b
Regression line y-intercept
.TP
.B stat reg
Full regression summary (y = mx + b, r)
.SS T-Tests
.TP
.B stat ttest
One-sample t-test vs μ₀=0
.TP
.B stat ttest \fImu0\fR
One-sample t-test vs specified μ₀
.TP
.B stat ttest 2
Two-sample Welch's t-test (x vs y data)
.PP
Example:
.PP
.RS
>>> stat clear
.br
>>> data+ 23
.br
>>> data+ 25
.br
>>> data+ 27
.br
>>> data+ 22
.br
>>> data+ 26
.br
>>> stat
.br
n      = 5
.br
mean   = 24.6
.br
median = 25
.br
sdev   = 2.073644135
.br
>>> stat ttest 25
.br
t = -0.4330127
.br
df = 4
.br
(one-sample t-test vs μ₀=25)
.RE
.SH RANDOM NUMBERS
.SS Scalar Random
.TP
.B rand
Uniform random number in [0, 1)
.TP
.B randn
Standard normal random number
.TP
.B randi(\fImax\fB)
Random integer from 1 to max
.TP
.B randi(\fImin\fB, \fImax\fB)
Random integer from min to max
.SS Matrix Random
See MATRICES section for rand(m,n), randn(m,n), randi(max,m,n).
.SS Seeding
.TP
.B seed \fIn\fR
Set random seed for reproducibility
.SH TIME VALUE OF MONEY
Financial calculations using the standard TVM model.
.SS Variables
.TP
.B n
Number of periods
.TP
.B i \fRor\fB rate
Interest rate per period (as percentage)
.TP
.B pv
Present value
.TP
.B pmt
Payment per period
.TP
.B fv
Future value
.SS Commands
.TP
.B tvm
Show current TVM values
.TP
.B tvm \fIvar\fB = \fIvalue\fR
Set a TVM variable
.TP
.B tvm solve \fIvar\fR
Solve for unknown variable
.TP
.B tvm clear
Reset all TVM values
.PP
Example (loan calculation):
.PP
.RS
>>> tvm n = 360
.br
>>> tvm i = 0.5
.br
>>> tvm pv = 200000
.br
>>> tvm fv = 0
.br
>>> tvm solve pmt
.br
pmt = -1199.10
.RE
.SH EQUATION SOLVING
.SS Newton-Raphson Solver
.TP
.B newton \fIexpr\fB = \fItarget\fR
Solve equation using Newton's method
.TP
.B newton \fIexpr\fB = \fItarget\fB from \fIguess\fR
Solve with initial guess
.PP
Use \fBx\fR as the variable to solve for:
.PP
.RS
>>> newton x^2 = 2
.br
x = 1.41421356237...
.br
>>> newton sin(x) = 0.5 from 0
.br
x = 0.52359877559... (π/6)
.RE
.SS General Solver
.TP
.B solve \fIexpr\fR
Find root where expr = 0
.SH DISPLAY OPTIONS
.SS Display Modes
Use the \fBmode\fR command to change how results are displayed:
.TP
.B mode
Show current display mode
.TP
.B mode dec
Decimal display (default)
.TP
.B mode hex
Hexadecimal display for integers
.TP
.B mode bin
Binary display for integers
.TP
.B mode frac
Fraction display (e.g., 1/3 instead of 0.333...)
.TP
.B mode ieee
Educational IEEE floating-point breakdown
.SS Display Functions
One-off display without changing mode:
.TP
.B ieee(x) \fRor\fB explain(x)
Show detailed IEEE-style floating-point breakdown with sign bit,
exponent, mantissa in binary and decimal, and step-by-step calculation.
Excellent for teaching how floating-point numbers work.
.TP
.B printhex(x)
Display x in hexadecimal
.TP
.B printbin(x)
Display x in binary
.SS Precision
.TP
.B digits \fIn\fR
Set display precision (1 to 38 significant figures)
.SS Base Conversion Commands
.TP
.B hex \fIvalue\fR
Display value in hexadecimal
.TP
.B bin \fIvalue\fR
Display value in binary
.TP
.B oct \fIvalue\fR
Display value in octal
.SH RPN MODE
.B sc
supports Reverse Polish Notation (RPN) mode for HP calculator-style input.
.TP
.B rpn
Enter RPN mode
.TP
.B exit \fRor\fB quit
Exit RPN mode (return to algebraic)
.PP
In RPN mode, enter numbers followed by operators:
.PP
.RS
RPN> 3
.br
RPN> 4
.br
RPN> +
.br
= 7
.br
RPN> 2
.br
RPN> *
.br
= 14
.RE
.SS RPN Stack Commands
.TP
.B dup
Duplicate top of stack
.TP
.B drop
Remove top of stack
.TP
.B swap
Swap top two elements
.TP
.B clr
Clear the stack
.TP
.B stack
Show entire stack
.SH PLOTTING
ASCII plots for quick visualization. You can plot any expression containing x:
.TP
.B plot \fIexpr\fR
Plot expression from -10 to 10
.TP
.B plot \fIexpr\fB \fIa\fB:\fIb\fR
Plot expression over range [a, b]
.PP
Examples:
.PP
.RS
.nf
>>> plot sin(x)
>>> plot x^2 -5:5
>>> plot x^2+x -1:1
>>> plot isprime(x) 0:100
>>> f(x)=sin(x)/x
>>> plot f(x)
.fi
.RE
.SH PIPE MODE
When input is piped or redirected,
.B sc
runs in quiet mode without prompts or the "= " prefix:
.PP
.RS
$ echo "sqrt(2)" | sc
.br
1.41421356237...
.br
$ echo "2+2" | sc
.br
4
.RE
.SH EXAMPLES
.SS Basic Calculations
.PP
.RS
>>> 2 + 3 * 4
.br
= 14
.br
>>> (1 + sqrt(5)) / 2
.br
= 1.6180339887... (golden ratio)
.br
>>> 100 * (1.05)^10
.br
= 162.889462678...
.RE
.SS Complex Numbers
.PP
.RS
>>> (1 + i)^10
.br
= 32i
.br
>>> e^(i*pi)
.br
= -1
.RE
.SS Matrix Operations
.PP
.RS
>>> A = [1 2 3; 4 5 6; 7 8 10]
.br
>>> det(A)
.br
= -3
.br
>>> inv(A) * A
.br
   1   0   0
.br
   0   1   0
.br
   0   0   1
.RE
.SS Solving Systems of Equations
.PP
Solve: 2x + y = 5, x - y = 1
.PP
.RS
>>> A = [2 1; 1 -1]
.br
>>> b = [5; 1]
.br
>>> A \\\\ b
.br
   2
.br
   1
.RE
.SH IEEE 754 COMPLIANCE
.B sc
implements IEEE 754-2008 compliant special value handling:
.PP
.RS
>>> 1/0
.br
= inf
.br
>>> -1/0
.br
= -inf
.br
>>> 0/0
.br
= nan
.br
>>> inf - inf
.br
= nan
.br
>>> inf + inf
.br
= inf
.br
>>> 0 * inf
.br
= nan
.RE
.SH FILES
.TP
.I ~/.scrc
User configuration file (future feature)
.SH ENVIRONMENT
.TP
.B SC_DIGITS
Default display precision
.SH EXIT STATUS
.TP
.B 0
Success
.TP
.B 1
Error in expression or command
.SH SEE ALSO
.BR bc (1),
.BR dc (1),
.BR calc (1)
.SH HOMEPAGE
https://github.com/dr-who/sc
.SH BUGS
Report bugs to: https://github.com/dr-who/sc/issues
.SH AUTHOR
Written for DOS and modern Unix systems.
.SH COPYRIGHT
This is free software; see the source for copying conditions.
