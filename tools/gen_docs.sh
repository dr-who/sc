#!/bin/bash
#
# gen_docs.sh - Generate documentation and tests from function documentation
#
# Uses the func_*.c source files which contain FuncDoc arrays with
# doxygen-style documentation.
#
# Usage: ./tools/gen_docs.sh [manpage|tests|funclist|count|all]
#

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
SC_DIR="$(dirname "$SCRIPT_DIR")"
SC="$SC_DIR/bin/sc"

# Ensure calculator is built
if [ ! -x "$SC" ]; then
    echo "Building calculator first..."
    (cd "$SC_DIR" && make) || exit 1
fi

# Count documented functions from source
count_functions() {
    # Count FuncDoc entries (lines starting with {"name")
    grep -h '{"[a-z]' "$SC_DIR"/src/func_*.c 2>/dev/null | \
        grep -v 'NULL' | \
        grep 'CAT_' | wc -l
}

# Generate function list markdown from sc itself
gen_funclist() {
    cat << 'EOF'
# scalc Function Reference

This document lists all built-in functions organized by category.
Use `help <function>` within sc for detailed documentation including examples.

EOF

    # Use sc's own output, converting to markdown
    printf 'functions\nquit\n' | "$SC" 2>/dev/null | \
        grep -v "User-defined" | \
        grep -v "^$" | \
        while IFS= read -r line; do
            case "$line" in
                "Built-in Functions"*)
                    num=$(echo "$line" | grep -oE '[0-9]+')
                    echo "**Total: $num functions**"
                    echo ""
                    ;;
                *"==="*)
                    # Skip separator
                    ;;
                *"Use 'help"*)
                    # Skip hint
                    ;;
                *:)
                    # Category header
                    echo "## ${line%:}"
                    echo ""
                    ;;
                "  "*)
                    # Function list - format as inline code
                    echo "$line" | sed 's/  */ /g' | \
                        sed 's/ \([a-zA-Z][a-zA-Z0-9_]*\)/ `\1`/g' | \
                        sed 's/^ *//'
                    ;;
            esac
        done
    
    echo ""
    echo "---"
    echo ""
    echo "Use \`help <function>\` for detailed documentation."
    echo ""
    echo "Use \`demo <function>\` to see examples executed live."
}

# Generate man page section
gen_manpage() {
    cat << 'EOF'
.\" Auto-generated function reference for sc(1)
.SH FUNCTIONS
This section lists all available functions by category.
Use \fBhelp <function>\fR for detailed documentation.
.PP
EOF
    
    # Use sc's own output
    printf 'functions\nquit\n' | "$SC" 2>/dev/null | \
        grep -v "User-defined" | \
        grep -v "^$" | \
        while IFS= read -r line; do
            case "$line" in
                *"total"*)
                    echo ".PP"
                    echo "$line"
                    ;;
                *:)
                    echo ".SS ${line%:}"
                    ;;
                "  "*)
                    # Wrap function names
                    echo "$line" | tr ' ' '\n' | grep -v '^$' | \
                        sed 's/^/.BR /' | tr '\n' ' '
                    echo ""
                    ;;
                *)
                    echo "$line"
                    ;;
            esac
        done
}

# Generate test script from documentation examples
gen_tests() {
    cat << 'HEADER'
#!/bin/bash
#
# test_funcs_generated.sh - Auto-generated tests from function documentation
# Generated by tools/gen_docs.sh
#

SC="${SC:-./bin/sc}"
PASS=0
FAIL=0

test_expr() {
    local result
    result=$("$SC" "$1" 2>&1 | head -1)
    if [ $? -eq 0 ] && ! echo "$result" | grep -qi "error"; then
        PASS=$((PASS + 1))
    else
        echo "  FAIL: $1 -> $result"
        FAIL=$((FAIL + 1))
    fi
}

test_exact() {
    local result expected="$2"
    result=$("$SC" "$1" 2>&1 | head -1)
    # Handle boolean true/false vs 1/0
    case "$result" in
        true) result=1 ;;
        false) result=0 ;;
    esac
    if [ "$result" = "$expected" ] || echo "$result" | grep -qE "^= ?$expected$"; then
        PASS=$((PASS + 1))
    else
        echo "  FAIL: $1 = '$result' (expected '$expected')"
        FAIL=$((FAIL + 1))
    fi
}

# Approximate comparison for floats
test_approx() {
    local result expected="$2" tol="${3:-0.0001}"
    result=$("$SC" "$1" 2>&1 | head -1)
    
    # Check for error
    if echo "$result" | grep -qi "error"; then
        echo "  FAIL: $1 -> $result"
        FAIL=$((FAIL + 1))
        return
    fi
    
    # Strip = prefix
    result=$(echo "$result" | sed 's/^= //')
    
    # Compare numerically using bc
    if command -v bc >/dev/null 2>&1; then
        local diff
        diff=$(echo "scale=10; x=$result - ($expected); if(x<0) -x else x" | bc 2>/dev/null)
        if [ -n "$diff" ] && echo "$diff < $tol" | bc -l 2>/dev/null | grep -q 1; then
            PASS=$((PASS + 1))
            return
        fi
    fi
    
    # Fallback: check if starts with expected
    if echo "$result" | grep -q "^$expected"; then
        PASS=$((PASS + 1))
    else
        echo "  FAIL: $1 = '$result' (expected ~$expected)"
        FAIL=$((FAIL + 1))
    fi
}

echo "=== GENERATED FUNCTION TESTS ==="
echo ""

HEADER

    # Extract examples from all func_*.c files
    for f in "$SC_DIR"/src/func_*.c; do
        [ -f "$f" ] || continue
        
        name=$(basename "$f" .c | sed 's/func_//')
        echo "echo \"Testing: $name\""
        
        # Find example strings
        grep -oE '\{"[^"]+\s*=\s*[^"]+"\}?' "$f" 2>/dev/null | \
            sed 's/[{}]//g; s/"//g' | \
            while IFS= read -r ex; do
                # Parse "expr = result"
                expr=$(echo "$ex" | cut -d= -f1 | sed 's/^ *//; s/ *$//')
                result=$(echo "$ex" | cut -d= -f2- | sed 's/^ *//; s/ *$//')
                
                # Skip complex/matrix examples
                echo "$expr" | grep -qE '\[.*\;' && continue
                echo "$result" | grep -qE '^\[' && continue
                echo "$expr" | grep -q '^\[' && echo "$expr" | grep -qv '^[a-z]' && continue
                [ -z "$expr" ] && continue
                
                # Generate test call based on result type
                case "$result" in
                    "")
                        # No expected result - just test it runs
                        echo "test_expr \"$expr\""
                        ;;
                    *i|*-*i|*+*i)
                        # Complex result - just test it runs
                        echo "test_expr \"$expr\""
                        ;;
                    true|false|1|0|-1)
                        # Boolean or simple integer
                        echo "test_exact \"$expr\" \"$result\""
                        ;;
                    *[0-9].*)
                        # Floating point - use approximate
                        echo "test_approx \"$expr\" \"$result\""
                        ;;
                    *)
                        # Other (integer, etc)
                        echo "test_exact \"$expr\" \"$result\""
                        ;;
                esac
            done
        
        echo ""
    done
    
    cat << 'FOOTER'
echo ""
echo "=== RESULTS: $PASS passed, $FAIL failed ==="
[ $FAIL -eq 0 ]
FOOTER
}

# Main
case "${1:-count}" in
    count)
        echo "Functions documented: $(count_functions)"
        ;;
    funclist)
        gen_funclist
        ;;
    manpage)
        gen_manpage
        ;;
    tests)
        gen_tests
        ;;
    all)
        echo "Generating documentation..."
        mkdir -p "$SC_DIR/packaging"
        
        gen_funclist > "$SC_DIR/FUNCTIONS.md"
        echo "  Created FUNCTIONS.md"
        
        gen_manpage > "$SC_DIR/packaging/sc.1.functions"
        echo "  Created packaging/sc.1.functions"
        
        gen_tests > "$SC_DIR/tests/test_funcs_generated.sh"
        chmod +x "$SC_DIR/tests/test_funcs_generated.sh"
        echo "  Created tests/test_funcs_generated.sh"
        
        echo ""
        echo "Functions documented: $(count_functions)"
        ;;
    *)
        echo "Usage: $0 [manpage|tests|funclist|count|all]"
        exit 1
        ;;
esac
